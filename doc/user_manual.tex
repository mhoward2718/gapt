\documentclass[a4paper, 11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}

% Using a report without chapters
\renewcommand*\thesection{\arabic{section}}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  frame=lines
}

\title{GAPT - Generic Architecture for Proof Transformations \\ \vspace{0.5cm} User's manual}
\author{Giselle Reis \\ \texttt{giselle@logic.at}}

\begin{document}
\maketitle

\section{Introduction}

Talk about the system, the motivation, the ceres method and the necessary
previous knowledge.

% TODO: put references.
Required knowledge:
\begin{itemize}
  \item Proof theory
  \item Cut-elimination
  \item CERES method
\end{itemize}

\section{Running the system}

TODO: describe how to download the jars from the site and run them.

\section{Some useful \texttt{scala} tips}

If you want to assign the result of a method to a variable, use: 
\texttt{var v = method(args)}. Otherwise, the system will create a variable by 
itself. You can see it's name and type before the description, like this:

With a variable name:
\begin{lstlisting}
scala> var i = 12
i: Int = 12
\end{lstlisting}

Without a variable name (in this case, the system created the variable \texttt{res12}):
\begin{lstlisting}
scala> 12
res12: Int = 12
\end{lstlisting}

To see the value of a variable, just type it’s name and press enter.

The elements of a list in Scala are indexed using parenthesis. So if \texttt{lst} 
is a list, the first element is obtained by \texttt{lst(0)}. It is also possible 
to use the methods \texttt{lst.head} (for the first element) and \texttt{lst.tail} 
(for the rest of the list).

The elements of a tuple \texttt{t} of size $n$ are accessed by the methods 
\texttt{t.\_1}, \texttt{t.\_2}, … , \texttt{t.\_n}.

To quit the interactive shell, just type \texttt{:quit} and press enter.

\section{Top level commands}

After executing the client, you will get to an interactive \texttt{scala} shell 
from where it is possile to run the operations GAPT provides. You can see all of
them by typing \texttt{ceresHelp()} and pressing enter. In this section we will 
describe what each of these are.

The syntax for calling the methods are always the name of the method followed by
the arguments in parenthesis, separated by commas if there's more than one.

\paragraph{\textbf{loadProofs: String $\rightarrow$ List[(String, LKProof)]}}
This method will take as an argument a string that represents the path of a file
containing an xml proof (generated by HLK for example), and will return a list 
of pairs. It expects a file (the string of a proof will not work) and you can use 
the relative path. On the list returned, each pair is composed of a string and 
an object representing a proof within the system. The string is the name of the 
proof defined on the xml file, and it returns a list for the case that this file
contains more than one proof.

Example:
\begin{lstlisting}[mathescape]
scala> var proof = loadProofs("integration_tests/misc_test/src/test/resources/sk2.xml")
proof: List[(String, at.logic.calculi.lk.base.LKProof)] = List((p,ExistsRightRuleType( :- $\exists$(x.($\forall$(y.(((a P x) $\wedge$ (a Q y)))))), ForallRightRuleType( :- $\forall$(y.(((a P b) $\wedge$ (a Q y)))), AndRightRuleType( :- ((a P b) $\wedge$ (a Q \beta)), InitialRuleType( :- (a P b)), InitialRuleType( :- (a Q \beta)))))))
\end{lstlisting}

\paragraph{\textbf{printProofStats: LKProof $\rightarrow$ Unit}}
This method takes a proof and prints some statistics about it, namely the number
of unary, binary and cut rules. If you have a variable storing the result of 
\texttt{loadProofs(...)}, one way to get the first proof of the list is: 
\texttt{proof.head.\_2}. If \texttt{proof} is the one defined on the previous 
example:

\begin{lstlisting}
scala> printPoofStats(proof.head._2)
unary: 2
binary: 1
cuts: 0
\end{lstlisting}

Of course you can always assing this to a variable and use it as a parameter:

\begin{lstlisting}
scala> var theproof = proof.head._2
theproof: at.logic.calculi.lk.base.LKProof = ExistsRightRuleType( :- $\exists$(x.($\forall$(y.(((a P x) $\wedge$ (a Q y)))))), ForallRightRuleType( :- $\forall$(y.(((a P b) $\wedge$ (a Q y)))), AndRightRuleType( :- ((a P b) $\wedge$ (a Q \beta)), InitialRuleType( :- (a P b)), InitialRuleType( :- (a Q \beta)))))

scala> printPoofStats(theproof)
unary: 2
binary: 1
cuts: 0
\end{lstlisting}

\paragraph{\textbf{lkTolksk: LKProof $\rightarrow$ LKProof}}
This method takes a proof in classical logic (LK), such as one generated by HLK and 
loaded by the method \texttt{loadProofs}, and transforms it to a proof on the
calculus $\mathbf{LK}_{sk}$. This calculus was proposed to solve the problem of
Skolemization in higher-order logic, and it basically replaces eigenvariables
with Skolem terms. For more information, see \cite{Hetzl2011}.

% TODO: it would be nice to combine extractStruct,structToClausesList,prover9 etc.
%       to an example session for applying Ceres to a proof

\paragraph{\textbf{extractStruct: LKProof $\rightarrow$ Struct}}
Extracts a struct from a LKProof. A struct is referred to as a clause term in
\cite{Baaz2011}. I will give a quick definition of it. For more details and
for an explanation of this structure on the CERES method, please refer to
\cite{Baaz2011}, Chapter 6.

Given a proof with cuts, by removing all the inference rules that operate on end
sequent ancestors, we obtain a proof of the empty sequent (refutation). The
axioms of this refutation are represented by \textit{clause terms}. Clause
terms are $\{\oplus, \otimes\}$-terms over clause sets, and it's interpretation
is the following:

\begin{align*}
|\mathcal{C}| &= \mathcal{C} \text{ if $\mathcal{C}$ is a set of clauses.}\\
|X \oplus Y| &= |X| \cup |Y|\\
|X \otimes Y| &= |X| \times |Y|
\end{align*}

where $\mathcal{C} \times \mathcal{D} = \{ C \circ D | C \in \mathcal{C} \wedge
D \in \mathcal{D}\}$ and if $S = \Gamma \vdash \Delta$ and $S' = \Pi \vdash
\Lambda$, $S \circ S' = \Gamma, \Pi \vdash \Delta, \Lambda.$

\paragraph{\textbf{structToClausesList: Struct $\rightarrow$ List[Sequent]}} computes
the standard characteristic clause set
from the struct, see~\cite[Section 4.2.1]{WoltzenlogelPaleo09General} for details.

\paragraph{\textbf{prover9: List[Sequent],Seq[Clause] $\rightarrow$ Option[ResolutionProof[Clause]]}}
sends the input clause set (given as either List[Sequent] or Seq[Clause]) to prover9. Returns
the resolution proof obtained from replaying the output proof of prover9,
see~\cite{Dunchev12System} for details.


\bibliographystyle{plain}
\bibliography{references}
\end{document}
