\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  frame=lines
}

\title{User manual for GAPT system}
\author{Giselle Reis \\ \texttt{giselle@logic.at}}

\begin{document}
\maketitle

\section{Running the system}

TODO: describe how to download the jars from the site and run them.

\section{Some useful \texttt{scala} tips}

If you want to assign the result of a method to a variable, use: 
\texttt{var v = method(args)}. Otherwise, the system will create a variable by 
itself. You can see it's name and type before the description, like this:

With a variable name:
\begin{lstlisting}
scala> var i = 12
i: Int = 12
\end{lstlisting}

Without a variable name (in this case, the system created the variable \texttt{res12}):
\begin{lstlisting}
scala> 12
res12: Int = 12
\end{lstlisting}

To see the value of a variable, just type it’s name and press enter.

The elements of a list in Scala are indexed using parenthesis. So if \texttt{lst} 
is a list, the first element is obtained by \texttt{lst(0)}. It is also possible 
to use the methods \texttt{lst.head} (for the first element) and \texttt{lst.tail} 
(for the rest of the list).

The elements of a tuple \texttt{t} of size $n$ are accessed by the methods 
\texttt{t.\_1}, \texttt{t.\_2}, … , \texttt{t.\_n}.

\section{Top level commands}

After executing the client, you will get to an interactive \texttt{scala} shell 
from where it is possile to run the operations GAPT provides. You can see all of
them by typing \texttt{ceresHelp()} and pressing enter. In this section we will 
describe what each of these are.

The syntax for calling the methods are always the name of the method followed by
the arguments in parenthesis, separated by commas if there's more than one.

\paragraph{\textbf{loadProofs: String $\rightarrow$ List[(String, LKProof)]}}
This method will take as an argument a string that represents the path of a file
containing an xml proof (generated by HLK for example), and will return a list 
of pairs. It expects a file (the string of a proof will not work) and you can use 
the relative path. On the list returned, each pair is composed of a string and 
an object representing a proof within the system. The string is the name of the 
proof defined on the xml file, and it returns a list for the case that this file
contains more than one proof.

Example:
\begin{lstlisting}[mathescape]
scala> var proof = loadProofs("integration_tests/misc_test/src/test/resources/sk2.xml")
proof: List[(String, at.logic.calculi.lk.base.LKProof)] = List((p,ExistsRightRuleType( :- $\exists$(x.($\forall$(y.(((a P x) $\wedge$ (a Q y)))))), ForallRightRuleType( :- $\forall$(y.(((a P b) $\wedge$ (a Q y)))), AndRightRuleType( :- ((a P b) $\wedge$ (a Q \beta)), InitialRuleType( :- (a P b)), InitialRuleType( :- (a Q \beta)))))))
\end{lstlisting}

\paragraph{\textbf{printProofStats: LKProof $\rightarrow$ Unit}}
This method takes a proof and prints some statistics about it, namely the number
of unary, binary and cut rules. If you have a variable storing the result of 
\texttt{loadProofs(...)}, one way to get the first proof of the list is: 
\texttt{proof.head.\_2}. If \texttt{proof} is the one defined on the previous 
example:

\begin{lstlisting}
scala> printPoofStats(proof.head._2)
unary: 2
binary: 1
cuts: 0
\end{lstlisting}

Of course you can always assing this to a variable and use it as a parameter:

\begin{lstlisting}
scala> var theproof = proof.head._2
theproof: at.logic.calculi.lk.base.LKProof = ExistsRightRuleType( :- $\exists$(x.($\forall$(y.(((a P x) $\wedge$ (a Q y)))))), ForallRightRuleType( :- $\forall$(y.(((a P b) $\wedge$ (a Q y)))), AndRightRuleType( :- ((a P b) $\wedge$ (a Q \beta)), InitialRuleType( :- (a P b)), InitialRuleType( :- (a Q \beta)))))

scala> printPoofStats(theproof)
unary: 2
binary: 1
cuts: 0
\end{lstlisting}


\textcolor{red}{OBS: calling printPoofStats in a proof transformed to lksk gives the match error (tested in proofs sk2 and sk3):}
\begin{lstlisting}
scala.MatchError: ExistsSkRightRuleType(Set() :- Set($\exists$(($\lambda$x:i.$\forall$(($\lambda$y:i.$\wedge$(P(a:i, x:i): o, Q(a:i, y:i): o): o)): o)): o (label: Set())), ForallSkRightRuleType(Set() :- Set($\forall$(($\lambda$y:i.$\wedge$(P(a:i, b:i): o, Q(a:i, y:i): o): o)): o (label: Set(b:i))), AndRightRuleType( :- ((a P b) $\wedge$ (a Q s_{0}(b))), InitialRuleType(Set() :- Set(P(a:i, b:i): o (label: Set(b:i)))), InitialRuleType(Set() :- Set(Q(a:i, s_{0}(b:i):i): o (label: Set(b:i))))))) (of class at.logic.calculi.lksk.ExistsSkRightRule$$anon$2)
	at at.logic.algorithms.lk.statistics.getStatistics$.apply(statistics.scala:31)
	at at.logic.cli.GAPScalaInteractiveShellLibrary.printPoofStats$.apply(GAPScalaInteractiveShellLibrary.scala:70)
	at .<init>(<console>:17)
	at .<clinit>(<console>)
	at .<init>(<console>:11)
	at .<clinit>(<console>)
	at $export(<console>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.call(IMain.scala:592)
	at scala.tools.nsc.interpreter.IMain$Request$$anonfun$10.apply(IMain.scala:828)
	at scala.tools.nsc.interpreter.Line$$anonfun$1.apply$mcV$sp(Line.scala:43)
	at scala.tools.nsc.io.package$$anon$2.run(package.scala:31)
	at java.lang.Thread.run(Thread.java:679)
\end{lstlisting}

\paragraph{\textbf{lkTolksk: LKProof $\rightarrow$ LKProof}}
This method takes a proof in classical logic (such as one generated by HLK and 
loaded by the method \texttt{loadProofs}) and skolemizes it, transforming the 
variables of strong quantifiers into skolem terms. The result is a skolemized 
proof to which the ceres method can be applied.

\paragraph{\textbf{extractStruct: LKProof $\rightarrow$ Struct}}
Extracts a struct from a LKProof. What is a struct I am yet to find.


\end{document}
